============================= test session starts ==============================
platform linux -- Python 3.8.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/yanghong/Projects/SQLProject
collecting ... Successfully connected.
Database connection closed.
frontend begin test
 * Serving Flask app 'bookstore.serve' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
collected 33 items

fe/test/test_add_book.py::TestAddBook::test_ok ERROR                     [  3%]
fe/test/test_add_book.py::TestAddBook::test_error_non_exist_store_id ERROR [  6%]
fe/test/test_add_book.py::TestAddBook::test_error_exist_book_id ERROR    [  9%]
fe/test/test_add_book.py::TestAddBook::test_error_non_exist_user_id ERROR [ 12%]
fe/test/test_add_funds.py::TestAddFunds::test_ok ERROR                   [ 15%]
fe/test/test_add_funds.py::TestAddFunds::test_error_user_id ERROR        [ 18%]
fe/test/test_add_funds.py::TestAddFunds::test_error_password ERROR       [ 21%]
fe/test/test_add_stock_level.py::TestAddStockLevel::test_error_user_id ERROR [ 24%]
fe/test/test_add_stock_level.py::TestAddStockLevel::test_error_store_id ERROR [ 27%]
fe/test/test_add_stock_level.py::TestAddStockLevel::test_error_book_id ERROR [ 30%]
fe/test/test_add_stock_level.py::TestAddStockLevel::test_ok ERROR        [ 33%]
fe/test/test_bench.py::test_bench FAILED                                 [ 36%]
fe/test/test_create_store.py::TestCreateStore::test_ok FAILED            [ 39%]
fe/test/test_create_store.py::TestCreateStore::test_error_exist_store_id FAILED [ 42%]
fe/test/test_login.py::TestLogin::test_ok FAILED                         [ 45%]
fe/test/test_login.py::TestLogin::test_error_user_id PASSED              [ 48%]
fe/test/test_login.py::TestLogin::test_error_password PASSED             [ 51%]
fe/test/test_new_order.py::TestNewOrder::test_non_exist_book_id ERROR    [ 54%]
fe/test/test_new_order.py::TestNewOrder::test_low_stock_level ERROR      [ 57%]
fe/test/test_new_order.py::TestNewOrder::test_ok ERROR                   [ 60%]
fe/test/test_new_order.py::TestNewOrder::test_non_exist_user_id ERROR    [ 63%]
fe/test/test_new_order.py::TestNewOrder::test_non_exist_store_id ERROR   [ 66%]
fe/test/test_password.py::TestPassword::test_ok FAILED                   [ 69%]
fe/test/test_password.py::TestPassword::test_error_password PASSED       [ 72%]
fe/test/test_password.py::TestPassword::test_error_user_id PASSED        [ 75%]
fe/test/test_payment.py::TestPayment::test_ok ERROR                      [ 78%]
fe/test/test_payment.py::TestPayment::test_authorization_error ERROR     [ 81%]
fe/test/test_payment.py::TestPayment::test_not_suff_funds ERROR          [ 84%]
fe/test/test_payment.py::TestPayment::test_repeat_pay ERROR              [ 87%]
fe/test/test_register.py::TestRegister::test_register_ok PASSED          [ 90%]
fe/test/test_register.py::TestRegister::test_unregister_ok PASSED        [ 93%]
fe/test/test_register.py::TestRegister::test_unregister_error_authorization PASSED [ 96%]
fe/test/test_register.py::TestRegister::test_register_error_exist_user_id PASSED [100%]

==================================== ERRORS ====================================
____________________ ERROR at setup of TestAddBook.test_ok _____________________

self = <test_add_book.TestAddBook object at 0x7fc5de4c07c0>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        # do before test
        self.seller_id = "test_add_books_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_books_store_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.seller = register_new_seller(self.seller_id, self.password)

fe/test/test_add_book.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:55] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:55] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
_________ ERROR at setup of TestAddBook.test_error_non_exist_store_id __________

self = <test_add_book.TestAddBook object at 0x7fc5dda2e2b0>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        # do before test
        self.seller_id = "test_add_books_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_books_store_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.seller = register_new_seller(self.seller_id, self.password)

fe/test/test_add_book.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:55] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:55] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________ ERROR at setup of TestAddBook.test_error_exist_book_id ____________

self = <test_add_book.TestAddBook object at 0x7fc5dda4c3a0>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        # do before test
        self.seller_id = "test_add_books_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_books_store_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.seller = register_new_seller(self.seller_id, self.password)

fe/test/test_add_book.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:55] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:55] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
__________ ERROR at setup of TestAddBook.test_error_non_exist_user_id __________

self = <test_add_book.TestAddBook object at 0x7fc5dda16b80>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        # do before test
        self.seller_id = "test_add_books_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_books_store_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.seller = register_new_seller(self.seller_id, self.password)

fe/test/test_add_book.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:56] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:56] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________________ ERROR at setup of TestAddFunds.test_ok ____________________

self = <test_add_funds.TestAddFunds object at 0x7fc5ddb3fcd0>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.user_id = "test_add_funds_{}".format(str(uuid.uuid1()))
        self.password = self.user_id
>       self.buyer = register_new_buyer(self.user_id, self.password)

fe/test/test_add_funds.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:56] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:56] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
______________ ERROR at setup of TestAddFunds.test_error_user_id _______________

self = <test_add_funds.TestAddFunds object at 0x7fc5e08c7a30>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.user_id = "test_add_funds_{}".format(str(uuid.uuid1()))
        self.password = self.user_id
>       self.buyer = register_new_buyer(self.user_id, self.password)

fe/test/test_add_funds.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:56] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:56] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
______________ ERROR at setup of TestAddFunds.test_error_password ______________

self = <test_add_funds.TestAddFunds object at 0x7fc5dda158b0>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.user_id = "test_add_funds_{}".format(str(uuid.uuid1()))
        self.password = self.user_id
>       self.buyer = register_new_buyer(self.user_id, self.password)

fe/test/test_add_funds.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________ ERROR at setup of TestAddStockLevel.test_error_user_id ____________

self = <test_add_stock_level.TestAddStockLevel object at 0x7fc5dd9cd7c0>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.user_id = "test_add_book_stock_level1_user_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_book_stock_level1_store_{}".format(str(uuid.uuid1()))
        self.password = self.user_id
>       self.seller = register_new_seller(self.user_id, self.password)

fe/test/test_add_stock_level.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
___________ ERROR at setup of TestAddStockLevel.test_error_store_id ____________

self = <test_add_stock_level.TestAddStockLevel object at 0x7fc5dd987b50>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.user_id = "test_add_book_stock_level1_user_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_book_stock_level1_store_{}".format(str(uuid.uuid1()))
        self.password = self.user_id
>       self.seller = register_new_seller(self.user_id, self.password)

fe/test/test_add_stock_level.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________ ERROR at setup of TestAddStockLevel.test_error_book_id ____________

self = <test_add_stock_level.TestAddStockLevel object at 0x7fc5dd984d30>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.user_id = "test_add_book_stock_level1_user_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_book_stock_level1_store_{}".format(str(uuid.uuid1()))
        self.password = self.user_id
>       self.seller = register_new_seller(self.user_id, self.password)

fe/test/test_add_stock_level.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:57] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
_________________ ERROR at setup of TestAddStockLevel.test_ok __________________

self = <test_add_stock_level.TestAddStockLevel object at 0x7fc5dd9e2e80>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.user_id = "test_add_book_stock_level1_user_{}".format(str(uuid.uuid1()))
        self.store_id = "test_add_book_stock_level1_store_{}".format(str(uuid.uuid1()))
        self.password = self.user_id
>       self.seller = register_new_seller(self.user_id, self.password)

fe/test/test_add_stock_level.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:58] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:58] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________ ERROR at setup of TestNewOrder.test_non_exist_book_id _____________

self = <test_new_order.TestNewOrder object at 0x7fc5dd999a60>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.buyer = register_new_buyer(self.buyer_id, self.password)

fe/test/test_new_order.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:59] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:59] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
_____________ ERROR at setup of TestNewOrder.test_low_stock_level ______________

self = <test_new_order.TestNewOrder object at 0x7fc5dd9d4790>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.buyer = register_new_buyer(self.buyer_id, self.password)

fe/test/test_new_order.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:00] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:00] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________________ ERROR at setup of TestNewOrder.test_ok ____________________

self = <test_new_order.TestNewOrder object at 0x7fc5dd912850>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.buyer = register_new_buyer(self.buyer_id, self.password)

fe/test/test_new_order.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:00] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:00] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________ ERROR at setup of TestNewOrder.test_non_exist_user_id _____________

self = <test_new_order.TestNewOrder object at 0x7fc5dd888550>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.buyer = register_new_buyer(self.buyer_id, self.password)

fe/test/test_new_order.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:00] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:00] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________ ERROR at setup of TestNewOrder.test_non_exist_store_id ____________

self = <test_new_order.TestNewOrder object at 0x7fc5dd87b460>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_new_order_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_new_order_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_new_order_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       self.buyer = register_new_buyer(self.buyer_id, self.password)

fe/test/test_new_order.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_buyer.py:9: in register_new_buyer
    s = buyer.Buyer(conf.URL, user_id, password)
fe/access/buyer.py:15: in __init__
    code, self.token = self.auth.login(self.user_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________________ ERROR at setup of TestPayment.test_ok _____________________

self = <test_payment.TestPayment object at 0x7fc5dda16970>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       gen_book = GenBook(self.seller_id, self.store_id)

fe/test/test_payment.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/test/gen_book_data.py:11: in __init__
    self.seller = register_new_seller(self.user_id, self.password)
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
____________ ERROR at setup of TestPayment.test_authorization_error ____________

self = <test_payment.TestPayment object at 0x7fc5dd8d7790>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       gen_book = GenBook(self.seller_id, self.store_id)

fe/test/test_payment.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/test/gen_book_data.py:11: in __init__
    self.seller = register_new_seller(self.user_id, self.password)
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:02] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:02] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
______________ ERROR at setup of TestPayment.test_not_suff_funds _______________

self = <test_payment.TestPayment object at 0x7fc5dda640d0>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       gen_book = GenBook(self.seller_id, self.store_id)

fe/test/test_payment.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/test/gen_book_data.py:11: in __init__
    self.seller = register_new_seller(self.user_id, self.password)
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:02] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:02] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
________________ ERROR at setup of TestPayment.test_repeat_pay _________________

self = <test_payment.TestPayment object at 0x7fc5dda2c430>

    @pytest.fixture(autouse=True)
    def pre_run_initialization(self):
        self.seller_id = "test_payment_seller_id_{}".format(str(uuid.uuid1()))
        self.store_id = "test_payment_store_id_{}".format(str(uuid.uuid1()))
        self.buyer_id = "test_payment_buyer_id_{}".format(str(uuid.uuid1()))
        self.password = self.seller_id
>       gen_book = GenBook(self.seller_id, self.store_id)

fe/test/test_payment.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/test/gen_book_data.py:11: in __init__
    self.seller = register_new_seller(self.user_id, self.password)
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:02] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:02] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
=================================== FAILURES ===================================
__________________________________ test_bench __________________________________

    def test_bench():
        try:
>           run_bench()

fe/test/test_bench.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def run_bench():
        wl = Workload()
>       wl.gen_database()

fe/bench/run.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fe.bench.workload.Workload object at 0x7fc5dd9b2190>

    def gen_database(self):
        logging.info("load data")
        for i in range(1, self.seller_num + 1):
            user_id, password = self.to_seller_id_and_password(i)
>           seller = register_new_seller(user_id, password)

fe/bench/workload.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_id = 'seller_1_e2ff7ae2-5bf3-11ec-8fb2-00155db1fd38'
password = 'password_seller_1_e2ff7ae2-5bf3-11ec-8fb2-00155db1fd38'

    def register_new_seller(user_id, password) -> seller.Seller:
        a = auth.Auth(conf.URL)
        code = a.register(user_id, password)
        assert code == 200
>       s = seller.Seller(conf.URL, user_id, password)

fe/access/new_seller.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fe.access.seller.Seller object at 0x7fc5dd9b2580>
url_prefix = 'http://127.0.0.1:5000/'
seller_id = 'seller_1_e2ff7ae2-5bf3-11ec-8fb2-00155db1fd38'
password = 'password_seller_1_e2ff7ae2-5bf3-11ec-8fb2-00155db1fd38'

    def __init__(self, url_prefix, seller_id: str, password: str):
        self.url_prefix = urljoin(url_prefix, "seller/")
        self.seller_id = seller_id
        self.password = password
        self.terminal = "my terminal"
        self.auth = Auth(url_prefix)
>       code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)

fe/access/seller.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fe.access.auth.Auth object at 0x7fc5dd9b2370>
user_id = 'seller_1_e2ff7ae2-5bf3-11ec-8fb2-00155db1fd38'
password = 'password_seller_1_e2ff7ae2-5bf3-11ec-8fb2-00155db1fd38'
terminal = 'my terminal'

    def login(self, user_id: str, password: str, terminal: str) -> (int, str):
        json = {"user_id": user_id, "password": password, "terminal": terminal}
        url = urljoin(self.url_prefix, "login")
        r = requests.post(url, json=json)
>       return r.status_code, r.json().get("token")

fe/access/auth.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [500]>, kwargs = {}

    def json(self, **kwargs):
        r"""Returns the json-encoded content of a response, if any.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises ValueError: If the response body does not contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using chardet to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(
                        self.content.decode(encoding), **kwargs
                    )
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
>       return complexjson.loads(self.text, **kwargs)

/usr/lib/python3/dist-packages/requests/models.py:897: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
encoding = None, cls = None, object_hook = None, parse_float = None
parse_int = None, parse_constant = None, object_pairs_hook = None
use_decimal = False, kw = {}

    def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,
            parse_int=None, parse_constant=None, object_pairs_hook=None,
            use_decimal=False, **kw):
        """Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON
        document) to a Python object.
    
        *encoding* determines the encoding used to interpret any
        :class:`str` objects decoded by this instance (``'utf-8'`` by
        default).  It has no effect when decoding :class:`unicode` objects.
    
        Note that currently only encodings that are a superset of ASCII work,
        strings of other encodings should be passed in as :class:`unicode`.
    
        *object_hook*, if specified, will be called with the result of every
        JSON object decoded and its return value will be used in place of the
        given :class:`dict`.  This can be used to provide custom
        deserializations (e.g. to support JSON-RPC class hinting).
    
        *object_pairs_hook* is an optional function that will be called with
        the result of any object literal decode with an ordered list of pairs.
        The return value of *object_pairs_hook* will be used instead of the
        :class:`dict`.  This feature can be used to implement custom decoders
        that rely on the order that the key and value pairs are decoded (for
        example, :func:`collections.OrderedDict` will remember the order of
        insertion). If *object_hook* is also defined, the *object_pairs_hook*
        takes priority.
    
        *parse_float*, if specified, will be called with the string of every
        JSON float to be decoded.  By default, this is equivalent to
        ``float(num_str)``. This can be used to use another datatype or parser
        for JSON floats (e.g. :class:`decimal.Decimal`).
    
        *parse_int*, if specified, will be called with the string of every
        JSON int to be decoded.  By default, this is equivalent to
        ``int(num_str)``.  This can be used to use another datatype or parser
        for JSON integers (e.g. :class:`float`).
    
        *parse_constant*, if specified, will be called with one of the
        following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This
        can be used to raise an exception if invalid JSON numbers are
        encountered.
    
        If *use_decimal* is true (default: ``False``) then it implies
        parse_float=decimal.Decimal for parity with ``dump``.
    
        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
        kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead
        of subclassing whenever possible.
    
        """
        if (cls is None and encoding is None and object_hook is None and
                parse_int is None and parse_float is None and
                parse_constant is None and object_pairs_hook is None
                and not use_decimal and not kw):
>           return _default_decoder.decode(s)

/usr/lib/python3/dist-packages/simplejson/__init__.py:518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
_w = <built-in method match of re.Pattern object at 0x7fc5e157de70>, _PY3 = True

    def decode(self, s, _w=WHITESPACE.match, _PY3=PY3):
        """Return the Python representation of ``s`` (a ``str`` or ``unicode``
        instance containing a JSON document)
    
        """
        if _PY3 and isinstance(s, bytes):
            s = str(s, self.encoding)
>       obj, end = self.raw_decode(s)

/usr/lib/python3/dist-packages/simplejson/decoder.py:370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError

During handling of the above exception, another exception occurred:

    def test_bench():
        try:
            run_bench()
        except Exception as e:
>           assert 200==100,"test_bench过程出现异常"
E           AssertionError: test_bench过程出现异常
E           assert 200 == 100
E             +200
E             -100

fe/test/test_bench.py:8: AssertionError
----------------------------- Captured stdout call -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log call -------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:58] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:58] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
___________________________ TestCreateStore.test_ok ____________________________

self = <test_create_store.TestCreateStore object at 0x7fc5dda91310>

    def test_ok(self):
>       self.seller = register_new_seller(self.user_id, self.password)

fe/test/test_create_store.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
----------------------------- Captured stdout call -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log call -------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:58] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:58] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
__________________ TestCreateStore.test_error_exist_store_id ___________________

self = <test_create_store.TestCreateStore object at 0x7fc5dd96c3a0>

    def test_error_exist_store_id(self):
>       self.seller = register_new_seller(self.user_id, self.password)

fe/test/test_create_store.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/new_seller.py:9: in register_new_seller
    s = seller.Seller(conf.URL, user_id, password)
fe/access/seller.py:14: in __init__
    code, self.token = self.auth.login(self.seller_id, self.password, self.terminal)
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
----------------------------- Captured stdout call -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log call -------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:59] "POST /auth/register HTTP/1.1" 200 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:59] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
______________________________ TestLogin.test_ok _______________________________

self = <test_login.TestLogin object at 0x7fc5dda9d640>

    def test_ok(self):
>       code, token = self.auth.login(self.user_id, self.password, self.terminal)

fe/test/test_login.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:59] "POST /auth/register HTTP/1.1" 200 -
----------------------------- Captured stdout call -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log call -------------------------------
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:05:59] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
_____________________________ TestPassword.test_ok _____________________________

self = <test_password.TestPassword object at 0x7fc5dd9a1ee0>

    def test_ok(self):
        code = self.auth.password(self.user_id, self.old_password, self.new_password)
        assert code == 200
    
        code, new_token = self.auth.login(self.user_id, self.old_password, self.terminal)
        assert code != 200
    
>       code, new_token = self.auth.login(self.user_id, self.new_password, self.terminal)

fe/test/test_password.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fe/access/auth.py:13: in login
    return r.status_code, r.json().get("token")
/usr/lib/python3/dist-packages/requests/models.py:897: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:518: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fc5e00ec550>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fc5e157de70>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
---------------------------- Captured stdout setup -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log setup ------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "POST /auth/register HTTP/1.1" 200 -
----------------------------- Captured stdout call -----------------------------
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
Successfully connected.
Database connection closed.
Successfully connected.
------------------------------ Captured log call -------------------------------
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "POST /auth/password HTTP/1.1" 200 -
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "[31m[1mPOST /auth/login HTTP/1.1[0m" 401 -
ERROR    bookstore.serve:app.py:1457 Exception on /auth/login [POST]
Traceback (most recent call last):
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 2073, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1518, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1516, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/yanghong/.local/lib/python3.8/site-packages/flask/app.py", line 1502, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)
  File "/home/yanghong/Projects/SQLProject/bookstore/bp/auth.py", line 55, in login
    token = Token.add_token(user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 43, in add_token
    code = encode(time.time(), user_id, password, terminal)
  File "/home/yanghong/Projects/SQLProject/bookstore/Token.py", line 16, in encode
    s = "{}-{}".format(t, sha256(s))
TypeError: Unicode-objects must be encoded before hashing
INFO     werkzeug:_internal.py:225 127.0.0.1 - - [13/Dec/2021 17:06:01] "[35m[1mPOST /auth/login HTTP/1.1[0m" 500 -
=========================== short test summary info ============================
FAILED fe/test/test_bench.py::test_bench - AssertionError: test_bench过程出现...
FAILED fe/test/test_create_store.py::TestCreateStore::test_ok - simplejson.er...
FAILED fe/test/test_create_store.py::TestCreateStore::test_error_exist_store_id
FAILED fe/test/test_login.py::TestLogin::test_ok - simplejson.errors.JSONDeco...
FAILED fe/test/test_password.py::TestPassword::test_ok - simplejson.errors.JS...
ERROR fe/test/test_add_book.py::TestAddBook::test_ok - simplejson.errors.JSON...
ERROR fe/test/test_add_book.py::TestAddBook::test_error_non_exist_store_id - ...
ERROR fe/test/test_add_book.py::TestAddBook::test_error_exist_book_id - simpl...
ERROR fe/test/test_add_book.py::TestAddBook::test_error_non_exist_user_id - s...
ERROR fe/test/test_add_funds.py::TestAddFunds::test_ok - simplejson.errors.JS...
